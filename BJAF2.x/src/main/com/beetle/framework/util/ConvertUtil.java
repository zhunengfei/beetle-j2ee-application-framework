/* Generated by Together */

/*
 * BJAF - Beetle J2EE Application Framework
 * 甲壳虫J2EE企业应用开发框架
 * 版权所有2003-2015 余浩东 (www.beetlesoft.net)
 * 
 * 这是一个免费开源的软件，您必须在
 *<http://www.apache.org/licenses/LICENSE-2.0>
 *协议下合法使用、修改或重新发布。
 *
 * 感谢您使用、推广本框架，若有建议或问题，欢迎您和我联系。
 * 邮件： <yuhaodong@gmail.com/>.
 */
package com.beetle.framework.util;

import java.io.IOException;
import java.text.ParseException;
import java.util.Date;

import static java.lang.System.arraycopy;

public class ConvertUtil {

	private static char[] hexDigits = { '0', '1', '2', '3', '4', '5', '6', '7',
			'8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

	/**
	 * Returns a hex string representation of a 8 bit integer. Very fast.
	 * Returned hex values are in uppercase.
	 * 
	 * @param b
	 *            byte to convert to hex string
	 * 
	 * @return hex value
	 */
	public static String toHexString(int b) {
		char[] digits = new char[2];
		b = b & 255;

		digits[0] = hexDigits[b / 0x10];
		digits[1] = hexDigits[b % 0x10];

		return new String(digits);
	}

	public static Date toDateByFormat(String dateString, String formatStr) {
		java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(
				formatStr);
		try {
			return sdf.parse(dateString);
		} catch (ParseException ex) {
			ex.printStackTrace();
			return null;
		}
	}

	public static String dateFormat(java.util.Date date, String formatStr) {
		java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(
				formatStr);
		return sdf.format(date);
	}

	public static String convertHexStr(String inStr) {
		StringBuffer sb = new StringBuffer();
		char[] myBuffer = inStr.toCharArray();
		for (int i = 0; i < inStr.length(); i++) {
			short s = (short) myBuffer[i];
			String hexS = Integer.toHexString(s).toUpperCase();
			if (hexS.length() == 8) {
				sb.append("&#x" + hexS.substring(4) + ";");
			} else {
				sb.append("&#x" + hexS + ";");
			}
		}
		return sb.toString();
	}

	public static String unicodeToGB2312StrWeb(String str) {
		String s = null;
		if (str != null) {
			try {
				String s1 = new String(str.getBytes("GB2312"));
				s = convertHexStr(s1);
			} catch (Exception e) {
				s = null;
			}
		}
		return s;
	}

	// iso-8859-1 to unicode
	public static String iso8859_1Unicode(String str) {
		String s = null;
		if (str != null) {
			try {
				s = new String(str.getBytes("iso-8859-1"));
			} catch (Exception e) {
				s = null;
			}
		}
		return s;
	}

	public static String codeUTF8(String str) {
		String a = null;
		try {
			if (str != null) {
				a = new String(str.getBytes("ISO-8859-1"), "UTF-8");
			}
		} catch (Exception e) {
			a = null;
		}
		return a;
	}

	//
	public static String convertUTF8String2Unicode(String instr)
			throws IOException {
		int charindex = instr.length();
		int actualValue;
		int inputValue;
		StringBuffer sbtemp = new StringBuffer();

		for (int i = 0; i < charindex;) {

			actualValue = -1;
			inputValue = instr.charAt(i++);

			inputValue &= 0xff;

			if ((inputValue & 0x80) == 0) {
				actualValue = inputValue;
			} else if ((inputValue & 0xF8) == 0xF0) {
				actualValue = (inputValue & 0x1f) << 18;

				int nextByte = instr.charAt(i++) & 0xff;
				if ((nextByte & 0xC0) != 0x80) {
					throw new IOException("Invalid UTF-8 format");
				}
				actualValue += (nextByte & 0x3F) << 12;

				nextByte = instr.charAt(i++) & 0xff;
				if ((nextByte & 0xC0) != 0x80) {
					throw new IOException("Invalid UTF-8 format");
				}
				actualValue += (nextByte & 0x3F) << 6;

				nextByte = instr.charAt(i++) & 0xff;
				if ((nextByte & 0xC0) != 0x80) {
					throw new IOException("Invalid UTF-8 format");
				}
				actualValue += (nextByte & 0x3F);
			} else if ((inputValue & 0xF0) == 0xE0) {
				actualValue = (inputValue & 0x1f) << 12;

				int nextByte = instr.charAt(i++) & 0xff;
				if ((nextByte & 0xC0) != 0x80) {
					throw new IOException("Invalid UTF-8 format");
				}
				actualValue += (nextByte & 0x3F) << 6;

				nextByte = instr.charAt(i++) & 0xff;
				if ((nextByte & 0xC0) != 0x80) {
					throw new IOException("Invalid UTF-8 format");
				}
				actualValue += (nextByte & 0x3F);
			} else if ((inputValue & 0xE0) == 0xC0) {
				actualValue = (inputValue & 0x1f) << 6;

				int nextByte = instr.charAt(i++) & 0xff;
				if ((nextByte & 0xC0) != 0x80) {
					throw new IOException("Invalid UTF-8 format");
				}
				actualValue += (nextByte & 0x3F);
			}
			sbtemp.append((char) actualValue);
		}

		return sbtemp.toString();
	}

	//
	public static byte[] convertUnicode2UTF8Byte(String instr) {
		int len = instr.length();
		byte[] abyte = new byte[len << 2];
		int j = 0;
		for (int i = 0; i < len; i++) {
			char c = instr.charAt(i);

			if (c < 0x80) {
				abyte[j++] = (byte) c;
			} else if (c < 0x0800) {
				abyte[j++] = (byte) (((c >> 6) & 0x1F) | 0xC0);
				abyte[j++] = (byte) ((c & 0x3F) | 0x80);
			} else if (c < 0x010000) {
				abyte[j++] = (byte) (((c >> 12) & 0x0F) | 0xE0);
				abyte[j++] = (byte) (((c >> 6) & 0x3F) | 0x80);
				abyte[j++] = (byte) ((c & 0x3F) | 0x80);
			} else if (c < 0x200000) {
				abyte[j++] = (byte) (((c >> 18) & 0x07) | 0xF8);
				abyte[j++] = (byte) (((c >> 12) & 0x3F) | 0x80);
				abyte[j++] = (byte) (((c >> 6) & 0x3F) | 0x80);
				abyte[j++] = (byte) ((c & 0x3F) | 0x80);
			}
		}

		byte[] retbyte = new byte[j];
		arraycopy(abyte, 0, retbyte, 0, j);
		return retbyte;
	}

	public static byte[] unicode2Byte(String s) {
		int len = s.length();
		byte abyte[] = new byte[len << 1];
		int j = 0;
		for (int i = 0; i < len; i++) {
			char c = s.charAt(i);
			abyte[j++] = (byte) (c & 0xff);
			abyte[j++] = (byte) (c >> 8);
		}

		return abyte;
	}
}
